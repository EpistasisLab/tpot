{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>To try the  TPOT2 (alpha) please go here!</p> <p>Consider TPOT your Data Science Assistant. TPOT is a Python Automated Machine Learning tool that optimizes machine learning pipelines using genetic programming.</p> <p></p> <p> </p> <p></p> <p>TPOT will automate the most tedious part of machine learning by intelligently exploring thousands of possible pipelines to find the best one for your data.</p> <p></p> <p> <p>An example machine learning pipeline </p> <p></p> <p>Once TPOT is finished searching (or you get tired of waiting), it provides you with the Python code for the best pipeline it found so you can tinker with the pipeline from there.</p> <p></p> <p> <p>An example TPOT pipeline </p> <p></p> <p>TPOT is built on top of scikit-learn, so all of the code it generates should look familiar... if you're familiar with scikit-learn, anyway.</p> <p>TPOT is still under active development and we encourage you to check back on this repository regularly for updates.</p>"},{"location":"api/","title":"TPOT API","text":""},{"location":"api/#classification","title":"Classification","text":"<pre>class tpot.TPOTClassifier(generations=100, population_size=100,\n                          offspring_size=None, mutation_rate=0.9,\n                          crossover_rate=0.1,\n                          scoring='accuracy', cv=5,\n                          subsample=1.0, n_jobs=1,\n                          max_time_mins=None, max_eval_time_mins=5,\n                          random_state=None, config_dict=None,\n                          template=None,\n                          warm_start=False,\n                          memory=None,\n                          use_dask=False,\n                          periodic_checkpoint_folder=None,\n                          early_stop=None,\n                          verbosity=0,\n                          disable_update_check=False,\n                          log_file=None\n                          )</pre> source <p>Automated machine learning for supervised classification tasks.</p> <p>The TPOTClassifier performs an intelligent search over machine learning pipelines that can contain supervised classification models, preprocessors, feature selection techniques, and any other estimator or transformer that follows the scikit-learn API. The TPOTClassifier will also search over the hyperparameters of all objects in the pipeline.</p> <p>By default, TPOTClassifier will search over a broad range of supervised classification algorithms, transformers, and their parameters. However, the algorithms, transformers, and hyperparameters that the TPOTClassifier searches over can be fully customized using the <code>config_dict</code> parameter.</p> <p>Read more in the User Guide.</p> Parameters: generations: int or None optional (default=100)  Number of iterations to the run pipeline optimization process. It must be a positive number or None. If None, the parameter max_time_mins must be defined as the runtime limit.  Generally, TPOT will work better when you give it more generations (and therefore time) to optimize the pipeline.  TPOT will evaluate population_size + generations \u00d7 offspring_size pipelines in total.  population_size: int, optional (default=100)  Number of individuals to retain in the genetic programming population every generation. Must be a positive number.  Generally, TPOT will work better when you give it more individuals with which to optimize the pipeline.  offspring_size: int, optional (default=None)  Number of offspring to produce in each genetic programming generation. Must be a positive number. By default, the number of offspring is equal to the number of population size.  mutation_rate: float, optional (default=0.9)  Mutation rate for the genetic programming algorithm in the range [0.0, 1.0]. This parameter tells the GP algorithm how many pipelines to apply random changes to every generation.  mutation_rate + crossover_rate cannot exceed 1.0.  We recommend using the default parameter unless you understand how the mutation rate affects GP algorithms.  crossover_rate: float, optional (default=0.1)  Crossover rate for the genetic programming algorithm in the range [0.0, 1.0]. This parameter tells the genetic programming algorithm how many pipelines to \"breed\" every generation.  mutation_rate + crossover_rate cannot exceed 1.0.  We recommend using the default parameter unless you understand how the crossover rate affects GP algorithms.  scoring: string or callable, optional (default='accuracy')  Function used to evaluate the quality of a given pipeline for the classification problem. The following built-in scoring functions can be used:  'accuracy', 'adjusted_rand_score', 'average_precision', 'balanced_accuracy', 'f1', 'f1_macro', 'f1_micro', 'f1_samples', 'f1_weighted', 'neg_log_loss', 'precision' etc. (suffixes apply as with \u2018f1\u2019), 'recall' etc. (suffixes apply as with \u2018f1\u2019), \u2018jaccard\u2019 etc. (suffixes apply as with \u2018f1\u2019), 'roc_auc', \u2018roc_auc_ovr\u2019, \u2018roc_auc_ovo\u2019, \u2018roc_auc_ovr_weighted\u2019, \u2018roc_auc_ovo_weighted\u2019  If you would like to use a custom scorer, you can pass the callable object/function with signature scorer(estimator, X, y).  See the section on scoring functions for more details.   cv: int, cross-validation generator, or an iterable, optional (default=5)  Cross-validation strategy used when evaluating pipelines.  Possible inputs: <ul> <li>integer, to specify the number of folds in an unshuffled StratifiedKFold,</li> <li>An object to be used as a cross-validation generator, or</li> <li>An iterable yielding train/test splits.</li> subsample: float, optional (default=1.0)  Fraction of training samples that are used during the TPOT optimization process. Must be in the range (0.0, 1.0].  Setting subsample=0.5 tells TPOT to use a random subsample of half of the training data. This subsample will remain the same during the entire pipeline optimization process.  n_jobs: integer, optional (default=1)  Number of processes to use in parallel for evaluating pipelines during the TPOT optimization process.  Setting n_jobs=-1 will use as many cores as available on the computer. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for n_jobs = -2, all CPUs but one are used. Beware that using multiple processes on the same machine may cause memory issues for large datasets.  max_time_mins: integer or None, optional (default=None)  How many minutes TPOT has to optimize the pipeline.  If not None, this setting will allow TPOT to run until max_time_mins minutes elapsed and then stop. TPOT will stop earlier if generations is set and all generations are already evaluated.  max_eval_time_mins: float, optional (default=5)  How many minutes TPOT has to evaluate a single pipeline.  Setting this parameter to higher values will allow TPOT to evaluate more complex pipelines, but will also allow TPOT to run longer. Use this parameter to help prevent TPOT from wasting time on evaluating time-consuming pipelines.  random_state: integer or None, optional (default=None)  The seed of the pseudo random number generator used in TPOT.  Use this parameter to make sure that TPOT will give you the same results each time you run it against the same data set with that seed.  config_dict: Python dictionary, string, or None, optional (default=None)  A configuration dictionary for customizing the operators and parameters that TPOT searches in the optimization process.  Possible inputs are: <ul> <li>Python dictionary, TPOT will use your custom configuration,</li> <li>string 'TPOT light', TPOT will use a built-in configuration with only fast models and preprocessors, or</li> <li>string 'TPOT MDR', TPOT will use a built-in configuration specialized for genomic studies, or</li> <li>string 'TPOT sparse': TPOT will use a configuration dictionary with a one-hot encoder and the operators normally included in TPOT that also support sparse matrices, or</li> <li>None, TPOT will use the default TPOTClassifier configuration.</li> </ul> See the built-in configurations section for the list of configurations included with TPOT, and the custom configuration section for more information and examples of how to create your own TPOT configurations.  template: string (default=None)  Template of predefined pipeline structure. The option is for specifying a desired structure for the machine learning pipeline evaluated in TPOT.   So far this option only supports linear pipeline structure. Each step in the pipeline should be a main class of operators (Selector, Transformer, Classifier) or a specific operator (e.g. `SelectPercentile`) defined in TPOT operator configuration. If one step is a main class, TPOT will randomly assign all subclass operators (subclasses of [`SelectorMixin`](https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/feature_selection/base.py#L17), [`TransformerMixin`](https://scikit-learn.org/stable/modules/generated/sklearn.base.TransformerMixin.html), [`ClassifierMixin`](https://scikit-learn.org/stable/modules/generated/sklearn.base.ClassifierMixin.html) in scikit-learn) to that step. Steps in the template are delimited by \"-\", e.g. \"SelectPercentile-Transformer-Classifier\". By default value of template is None, TPOT generates tree-based pipeline randomly.  See the  template option in tpot section for more details.  warm_start: boolean, optional (default=False)  Flag indicating whether the TPOT instance will reuse the population from previous calls to fit().  Setting warm_start=True can be useful for running TPOT for a short time on a dataset, checking the results, then resuming the TPOT run from where it left off.  memory: a joblib.Memory object or string, optional (default=None)  If supplied, pipeline will cache each transformer after calling fit. This feature is used to avoid computing the fit transformers within a pipeline if the parameters and input data are identical with another fitted pipeline during optimization process. More details about memory caching in scikit-learn documentation  Possible inputs are: <ul> <li>String 'auto': TPOT uses memory caching with a temporary directory and cleans it up upon shutdown, or</li> <li>Path of a caching directory, TPOT uses memory caching with the provided directory and TPOT does NOT clean the caching directory up upon shutdown, or</li> <li>Memory object, TPOT uses the instance of joblib.Memory for memory caching and TPOT does NOT clean the caching directory up upon shutdown, or</li> <li>None, TPOT does not use memory caching.</li> </ul> use_dask: boolean, optional (default: False)  Whether to use Dask-ML's pipeline optimiziations. This avoid re-fitting the same estimator on the same split of data multiple times. It will also provide more detailed diagnostics when using Dask's distributed scheduler.  See avoid repeated work for more details.  periodic_checkpoint_folder: path string, optional (default: None)  If supplied, a folder in which TPOT will periodically save pipelines in pareto front so far while optimizing. Currently once per generation but not more often than once per 30 seconds. Useful in multiple cases: <ul> <li>Sudden death before TPOT could save optimized pipeline</li> <li>Track its progress</li> <li>Grab pipelines while it's still optimizing</li> </ul> early_stop: integer, optional (default: None)  How many generations TPOT checks whether there is no improvement in optimization process.  Ends the optimization process if there is no improvement in the given number of generations.  verbosity: integer, optional (default=0)  How much information TPOT communicates while it's running.  Possible inputs are: <ul> <li>0, TPOT will print nothing,</li> <li>1, TPOT will print minimal information,</li> <li>2, TPOT will print more information and provide a progress bar, or</li> <li>3, TPOT will print everything and provide a progress bar.</li> </ul> disable_update_check: boolean, optional (default=False)  Flag indicating whether the TPOT version checker should be disabled.  The update checker will tell you when a new version of TPOT has been released.  log_file: file-like class (io.TextIOWrapper or io.StringIO) or string, optional (default: None)   Save progress content to a file. If it is a string for the path and file name of the desired output file, TPOT will create the file and write log into it. If it is None, TPOT will output log into sys.stdout  Attributes: fitted_pipeline_: scikit-learn Pipeline object  The best pipeline that TPOT discovered during the pipeline optimization process, fitted on the entire training dataset.  pareto_front_fitted_pipelines_: Python dictionary  Dictionary containing the all pipelines on the TPOT Pareto front, where the key is the string representation of the pipeline and the value is the corresponding pipeline fitted on the entire training dataset.  The TPOT Pareto front provides a trade-off between pipeline complexity (i.e., the number of steps in the pipeline) and the predictive performance of the pipeline.  Note: pareto_front_fitted_pipelines_ is only available when verbosity=3.  evaluated_individuals_: Python dictionary  Dictionary containing all pipelines that were evaluated during the pipeline optimization process, where the key is the string representation of the pipeline and the value is a tuple containing (# of steps in pipeline, accuracy metric for the pipeline).  This attribute is primarily for internal use, but may be useful for looking at the other pipelines that TPOT evaluated.  <p>Example</p> <pre><code>from tpot import TPOTClassifier\nfrom sklearn.datasets import load_digits\nfrom sklearn.model_selection import train_test_split\ndigits = load_digits()\nX_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,\ntrain_size=0.75, test_size=0.25)\ntpot = TPOTClassifier(generations=5, population_size=50, verbosity=2)\ntpot.fit(X_train, y_train)\nprint(tpot.score(X_test, y_test))\ntpot.export('tpot_digits_pipeline.py')\n</code></pre> <p>Functions</p> fit(features, classes[, sample_weight, groups]) Run the TPOT optimization process on the given training data. predict(features) Use the optimized pipeline to predict the classes for a feature set. predict_proba(features) Use the optimized pipeline to estimate the class probabilities for a feature set. score(testing_features, testing_classes) Returns the optimized pipeline's score on the given testing data using the user-specified scoring function. export(output_file_name) Export the optimized pipeline as Python code. <p> <pre><code>fit(features, classes, sample_weight=None, groups=None)\n</code></pre></p>  Run the TPOT optimization process on the given training data.  Uses genetic programming to optimize a machine learning pipeline that maximizes the score on the provided features and target. This pipeline optimization procedure uses internal k-fold cross-validaton to avoid overfitting on the provided data. At the end of the pipeline optimization procedure, the best pipeline is then trained on the entire set of provided samples.  Parameters: features: array-like {n_samples, n_features}  Feature matrix  TPOT and all scikit-learn algorithms assume that the features will be numerical and there will be no missing values. As such, when a feature matrix is provided to TPOT, all missing values will automatically be replaced (i.e., imputed) using median value imputation.  If you wish to use a different imputation strategy than median imputation, please make sure to apply imputation to your feature set prior to passing it to TPOT.  classes: array-like {n_samples}  List of class labels for prediction  sample_weight: array-like {n_samples}, optional  Per-sample weights. Higher weights indicate more importance. If specified, sample_weight will be passed to any pipeline element whose fit() function accepts a sample_weight argument. By default, using sample_weight does not affect tpot's scoring functions, which determine preferences between pipelines.  groups: array-like, with shape {n_samples, }, optional  Group labels for the samples used when performing cross-validation.  This parameter should only be used in conjunction with sklearn's Group cross-validation functions, such as sklearn.model_selection.GroupKFold.  Returns: self: object  Returns a copy of the fitted TPOT object  <p> <pre><code>predict(features)\n</code></pre></p>  Use the optimized pipeline to predict the classes for a feature set.  Parameters: features: array-like {n_samples, n_features}  Feature matrix  Returns: predictions: array-like {n_samples}  Predicted classes for the samples in the feature matrix  <p> <pre><code>predict_proba(features)\n</code></pre></p>  Use the optimized pipeline to estimate the class probabilities for a feature set.  Note: This function will only work for pipelines whose final classifier supports the predict_proba function. TPOT will raise an error otherwise.  Parameters: features: array-like {n_samples, n_features}  Feature matrix  Returns: predictions: array-like {n_samples, n_classes}  The class probabilities of the input samples  <p> <pre><code>score(testing_features, testing_classes)\n</code></pre></p>  Returns the optimized pipeline's score on the given testing data using the user-specified scoring function.  The default scoring function for TPOTClassifier is 'accuracy'.  Parameters: testing_features: array-like {n_samples, n_features}  Feature matrix of the testing set  testing_classes: array-like {n_samples}  List of class labels for prediction in the testing set  Returns: accuracy_score: float  The estimated test set accuracy according to the user-specified scoring function.  <p> <pre><code>export(output_file_name, data_file_path)\n</code></pre></p>  Export the optimized pipeline as Python code.  See the usage documentation for example usage of the export function.  Parameters: output_file_name: string  String containing the path and file name of the desired output file  data_file_path: string  By default, the path of input dataset is 'PATH/TO/DATA/FILE' by default. If data_file_path is another string, the path will be replaced.  Returns: exported_code_string: string  The whole pipeline text as a string should be returned if output_file_name is not specified."},{"location":"api/#regression","title":"Regression","text":"<pre>class tpot.TPOTRegressor(generations=100, population_size=100,\n                         offspring_size=None, mutation_rate=0.9,\n                         crossover_rate=0.1,\n                         scoring='neg_mean_squared_error', cv=5,\n                         subsample=1.0, n_jobs=1,\n                         max_time_mins=None, max_eval_time_mins=5,\n                         random_state=None, config_dict=None,\n                         template=None,\n                         warm_start=False,\n                         memory=None,\n                         use_dask=False,\n                         periodic_checkpoint_folder=None,\n                         early_stop=None,\n                         verbosity=0,\n                         disable_update_check=False)</pre> source <p>Automated machine learning for supervised regression tasks.</p> <p>The TPOTRegressor performs an intelligent search over machine learning pipelines that can contain supervised regression models, preprocessors, feature selection techniques, and any other estimator or transformer that follows the scikit-learn API. The TPOTRegressor will also search over the hyperparameters of all objects in the pipeline.</p> <p>By default, TPOTRegressor will search over a broad range of supervised regression models, transformers, and their hyperparameters. However, the models, transformers, and parameters that the TPOTRegressor searches over can be fully customized using the <code>config_dict</code> parameter.</p> <p>Read more in the User Guide.</p> Parameters: generations: int or None, optional (default=100)  Number of iterations to the run pipeline optimization process. It must be a positive number or None. If None, the parameter max_time_mins must be defined as the runtime limit.  Generally, TPOT will work better when you give it more generations (and therefore time) to optimize the pipeline.  TPOT will evaluate population_size + generations \u00d7 offspring_size pipelines in total.  population_size: int, optional (default=100)  Number of individuals to retain in the genetic programming population every generation. Must be a positive number.  Generally, TPOT will work better when you give it more individuals with which to optimize the pipeline.  offspring_size: int, optional (default=None)  Number of offspring to produce in each genetic programming generation. Must be a positive number. By default, the number of offspring is equal to the number of population size.  mutation_rate: float, optional (default=0.9)  Mutation rate for the genetic programming algorithm in the range [0.0, 1.0]. This parameter tells the GP algorithm how many pipelines to apply random changes to every generation.  mutation_rate + crossover_rate cannot exceed 1.0.  We recommend using the default parameter unless you understand how the mutation rate affects GP algorithms.  crossover_rate: float, optional (default=0.1)  Crossover rate for the genetic programming algorithm in the range [0.0, 1.0]. This parameter tells the genetic programming algorithm how many pipelines to \"breed\" every generation.  mutation_rate + crossover_rate cannot exceed 1.0.  We recommend using the default parameter unless you understand how the crossover rate affects GP algorithms.  scoring: string or callable, optional (default='neg_mean_squared_error')  Function used to evaluate the quality of a given pipeline for the regression problem. The following built-in scoring functions can be used:  'neg_median_absolute_error', 'neg_mean_absolute_error', 'neg_mean_squared_error', 'r2'  Note that we recommend using the neg version of mean squared error and related metrics so TPOT will minimize (instead of maximize) the metric.  If you would like to use a custom scorer, you can pass the callable object/function with signature scorer(estimator, X, y).  See the section on scoring functions for more details.  cv: int, cross-validation generator, or an iterable, optional (default=5)  Cross-validation strategy used when evaluating pipelines.  Possible inputs: <ul> <li>integer, to specify the number of folds in an unshuffled KFold,</li> <li>An object to be used as a cross-validation generator, or</li> <li>An iterable yielding train/test splits.</li> </ul> subsample: float, optional (default=1.0)  Fraction of training samples that are used during the TPOT optimization process. Must be in the range (0.0, 1.0].  Setting subsample=0.5 tells TPOT to use a random subsample of half of the training data. This subsample will remain the same during the entire pipeline optimization process.  n_jobs: integer, optional (default=1)  Number of processes to use in parallel for evaluating pipelines during the TPOT optimization process.  Setting n_jobs=-1 will use as many cores as available on the computer. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for n_jobs = -2, all CPUs but one are used. Beware that using multiple processes on the same machine may cause memory issues for large datasets  max_time_mins: integer or None, optional (default=None)  How many minutes TPOT has to optimize the pipeline.  If not None, this setting will allow TPOT to run until max_time_mins minutes elapsed and then stop. TPOT will stop earlier if generations is set and all generations are already evaluated.  max_eval_time_mins: float, optional (default=5)  How many minutes TPOT has to evaluate a single pipeline.  Setting this parameter to higher values will allow TPOT to evaluate more complex pipelines, but will also allow TPOT to run longer. Use this parameter to help prevent TPOT from wasting time on evaluating time-consuming pipelines.  random_state: integer or None, optional (default=None)  The seed of the pseudo random number generator used in TPOT.  Use this parameter to make sure that TPOT will give you the same results each time you run it against the same data set with that seed.  config_dict: Python dictionary, string, or None, optional (default=None)  A configuration dictionary for customizing the operators and parameters that TPOT searches in the optimization process.  Possible inputs are: <ul> <li>Python dictionary, TPOT will use your custom configuration,</li> <li>string 'TPOT light', TPOT will use a built-in configuration with only fast models and preprocessors, or</li> <li>string 'TPOT MDR', TPOT will use a built-in configuration specialized for genomic studies, or</li> <li>string 'TPOT sparse': TPOT will use a configuration dictionary with a one-hot encoder and the operators normally included in TPOT that also support sparse matrices, or</li> <li>None, TPOT will use the default TPOTRegressor configuration.</li> </ul> See the built-in configurations section for the list of configurations included with TPOT, and the custom configuration section for more information and examples of how to create your own TPOT configurations.  template: string (default=None)  Template of predefined pipeline structure. The option is for specifying a desired structure for the machine learning pipeline evaluated in TPOT.   So far this option only supports linear pipeline structure. Each step in the pipeline should be a main class of operators (Selector, Transformer or Regressor) or a specific operator (e.g. `SelectPercentile`) defined in TPOT operator configuration. If one step is a main class, TPOT will randomly assign all subclass operators (subclasses of [`SelectorMixin`](https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/feature_selection/base.py#L17), [`TransformerMixin`](https://scikit-learn.org/stable/modules/generated/sklearn.base.TransformerMixin.html) or [`RegressorMixin`](https://scikit-learn.org/stable/modules/generated/sklearn.base.RegressorMixin.html) in scikit-learn) to that step. Steps in the template are delimited by \"-\", e.g. \"SelectPercentile-Transformer-Regressor\". By default value of template is None, TPOT generates tree-based pipeline randomly.  See the  template option in tpot section for more details.  warm_start: boolean, optional (default=False)  Flag indicating whether the TPOT instance will reuse the population from previous calls to fit().  Setting warm_start=True can be useful for running TPOT for a short time on a dataset, checking the results, then resuming the TPOT run from where it left off.  memory: a joblib.Memory object or string, optional (default=None)  If supplied, pipeline will cache each transformer after calling fit. This feature is used to avoid computing the fit transformers within a pipeline if the parameters and input data are identical with another fitted pipeline during optimization process. More details about memory caching in scikit-learn documentation  Possible inputs are: <ul> <li>String 'auto': TPOT uses memory caching with a temporary directory and cleans it up upon shutdown, or</li> <li>Path of a caching directory, TPOT uses memory caching with the provided directory and TPOT does NOT clean the caching directory up upon shutdown, or</li> <li>Memory object, TPOT uses the instance of joblib.Memory for memory caching and TPOT does NOT clean the caching directory up upon shutdown, or</li> <li>None, TPOT does not use memory caching.</li> </ul> use_dask: boolean, optional (default: False)  Whether to use Dask-ML's pipeline optimiziations. This avoid re-fitting the same estimator on the same split of data multiple times. It will also provide more detailed diagnostics when using Dask's distributed scheduler.  See avoid repeated work for more details.  periodic_checkpoint_folder: path string, optional (default: None)  If supplied, a folder in which TPOT will periodically save pipelines in pareto front so far while optimizing. Currently once per generation but not more often than once per 30 seconds. Useful in multiple cases: <ul> <li>Sudden death before TPOT could save optimized pipeline</li> <li>Track its progress</li> <li>Grab pipelines while it's still optimizing</li> </ul> early_stop: integer, optional (default: None)  How many generations TPOT checks whether there is no improvement in optimization process.  Ends the optimization process if there is no improvement in the given number of generations.  verbosity: integer, optional (default=0)  How much information TPOT communicates while it's running.  Possible inputs are: <ul> <li>0, TPOT will print nothing,</li> <li>1, TPOT will print minimal information,</li> <li>2, TPOT will print more information and provide a progress bar, or</li> <li>3, TPOT will print everything and provide a progress bar.</li> </ul> disable_update_check: boolean, optional (default=False)  Flag indicating whether the TPOT version checker should be disabled.  The update checker will tell you when a new version of TPOT has been released.  Attributes: fitted_pipeline_: scikit-learn Pipeline object  The best pipeline that TPOT discovered during the pipeline optimization process, fitted on the entire training dataset.  pareto_front_fitted_pipelines_: Python dictionary  Dictionary containing the all pipelines on the TPOT Pareto front, where the key is the string representation of the pipeline and the value is the corresponding pipeline fitted on the entire training dataset.  The TPOT Pareto front provides a trade-off between pipeline complexity (i.e., the number of steps in the pipeline) and the predictive performance of the pipeline.  Note: _pareto_front_fitted_pipelines is only available when verbosity=3.  evaluated_individuals_: Python dictionary  Dictionary containing all pipelines that were evaluated during the pipeline optimization process, where the key is the string representation of the pipeline and the value is a tuple containing (# of steps in pipeline, accuracy metric for the pipeline).  This attribute is primarily for internal use, but may be useful for looking at the other pipelines that TPOT evaluated.  <p>Example</p> <pre><code>from tpot import TPOTRegressor\nfrom sklearn.datasets import load_boston\nfrom sklearn.model_selection import train_test_split\ndigits = load_boston()\nX_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,\ntrain_size=0.75, test_size=0.25)\ntpot = TPOTRegressor(generations=5, population_size=50, verbosity=2)\ntpot.fit(X_train, y_train)\nprint(tpot.score(X_test, y_test))\ntpot.export('tpot_boston_pipeline.py')\n</code></pre> <p>Functions</p> fit(features, target[, sample_weight, groups]) Run the TPOT optimization process on the given training data. predict(features) Use the optimized pipeline to predict the target values for a feature set. score(testing_features, testing_target) Returns the optimized pipeline's score on the given testing data using the user-specified scoring function. export(output_file_name) Export the optimized pipeline as Python code. <p> <pre><code>fit(features, target, sample_weight=None, groups=None)\n</code></pre></p>  Run the TPOT optimization process on the given training data.  Uses genetic programming to optimize a machine learning pipeline that maximizes the score on the provided features and target. This pipeline optimization procedure uses internal k-fold cross-validaton to avoid overfitting on the provided data. At the end of the pipeline optimization procedure, the best pipeline is then trained on the entire set of provided samples.  Parameters: features: array-like {n_samples, n_features}  Feature matrix  TPOT and all scikit-learn algorithms assume that the features will be numerical and there will be no missing values. As such, when a feature matrix is provided to TPOT, all missing values will automatically be replaced (i.e., imputed) using median value imputation.  If you wish to use a different imputation strategy than median imputation, please make sure to apply imputation to your feature set prior to passing it to TPOT.  target: array-like {n_samples}  List of target labels for prediction  sample_weight: array-like {n_samples}, optional  Per-sample weights. Higher weights indicate more importance. If specified, sample_weight will be passed to any pipeline element whose fit() function accepts a sample_weight argument. By default, using sample_weight does not affect tpot's scoring functions, which determine preferences between pipelines.  groups: array-like, with shape {n_samples, }, optional  Group labels for the samples used when performing cross-validation.  This parameter should only be used in conjunction with sklearn's Group cross-validation functions, such as sklearn.model_selection.GroupKFold.  Returns: self: object  Returns a copy of the fitted TPOT object  <p> <pre><code>predict(features)\n</code></pre></p>  Use the optimized pipeline to predict the target values for a feature set.  Parameters: features: array-like {n_samples, n_features}  Feature matrix  Returns: predictions: array-like {n_samples}  Predicted target values for the samples in the feature matrix  <p> <pre><code>score(testing_features, testing_target)\n</code></pre></p>  Returns the optimized pipeline's score on the given testing data using the user-specified scoring function.  The default scoring function for TPOTRegressor is 'mean_squared_error'.  Parameters: testing_features: array-like {n_samples, n_features}  Feature matrix of the testing set  testing_target: array-like {n_samples}  List of target labels for prediction in the testing set  Returns: accuracy_score: float  The estimated test set accuracy according to the user-specified scoring function.  <p> <pre><code>export(output_file_name)\n</code></pre></p>  Export the optimized pipeline as Python code.  See the usage documentation for example usage of the export function.  Parameters: output_file_name: string  String containing the path and file name of the desired output file  data_file_path: string  By default, the path of input dataset is 'PATH/TO/DATA/FILE' by default. If data_file_path is another string, the path will be replaced.  Returns: exported_code_string: string  The whole pipeline text as a string should be returned if output_file_name is not specified."},{"location":"citing/","title":"Citing TPOT","text":"<p>If you use TPOT in a scientific publication, please consider citing at least one of the following papers:</p> <p>Trang T. Le, Weixuan Fu and Jason H. Moore (2020). Scaling tree-based automated machine learning to biomedical big data with a feature set selector. Bioinformatics.36(1): 250-256.</p> <p>BibTeX entry:</p> <pre><code>@article{le2020scaling,\ntitle={Scaling tree-based automated machine learning to biomedical big data with a feature set selector},\nauthor={Le, Trang T and Fu, Weixuan and Moore, Jason H},\njournal={Bioinformatics},\nvolume={36},\nnumber={1},\npages={250--256},\nyear={2020},\npublisher={Oxford University Press}\n}\n</code></pre> <p>Randal S. Olson, Ryan J. Urbanowicz, Peter C. Andrews, Nicole A. Lavender, La Creis Kidd, and Jason H. Moore (2016). Automating biomedical data science through tree-based pipeline optimization. Applications of Evolutionary Computation, pages 123-137.</p> <p>BibTeX entry:</p> <pre><code>@inbook{Olson2016EvoBio,\nauthor={Olson, Randal S. and Urbanowicz, Ryan J. and Andrews, Peter C. and Lavender, Nicole A. and Kidd, La Creis and Moore, Jason H.},\neditor={Squillero, Giovanni and Burelli, Paolo},\nchapter={Automating Biomedical Data Science Through Tree-Based Pipeline Optimization},\ntitle={Applications of Evolutionary Computation: 19th European Conference, EvoApplications 2016, Porto, Portugal, March 30 -- April 1, 2016, Proceedings, Part I},\nyear={2016},\npublisher={Springer International Publishing},\npages={123--137},\nisbn={978-3-319-31204-0},\ndoi={10.1007/978-3-319-31204-0_9},\nurl={http://dx.doi.org/10.1007/978-3-319-31204-0_9}\n}\n</code></pre> <p>Evaluation of a Tree-based Pipeline Optimization Tool for Automating Data Science</p> <p>Randal S. Olson, Nathan Bartley, Ryan J. Urbanowicz, and Jason H. Moore (2016). Evaluation of a Tree-based Pipeline Optimization Tool for Automating Data Science. Proceedings of GECCO 2016, pages 485-492.</p> <p>BibTeX entry:</p> <pre><code>@inproceedings{OlsonGECCO2016,\nauthor = {Olson, Randal S. and Bartley, Nathan and Urbanowicz, Ryan J. and Moore, Jason H.},\ntitle = {Evaluation of a Tree-based Pipeline Optimization Tool for Automating Data Science},\nbooktitle = {Proceedings of the Genetic and Evolutionary Computation Conference 2016},\nseries = {GECCO '16},\nyear = {2016},\nisbn = {978-1-4503-4206-3},\nlocation = {Denver, Colorado, USA},\npages = {485--492},\nnumpages = {8},\nurl = {http://doi.acm.org/10.1145/2908812.2908918},\ndoi = {10.1145/2908812.2908918},\nacmid = {2908918},\npublisher = {ACM},\naddress = {New York, NY, USA},\n}\n</code></pre> <p>Alternatively, you can cite the repository directly with the following DOI:</p> <p>DOI</p>"},{"location":"contributing/","title":"Contribution Guide","text":"<p>We welcome you to check the existing issues for bugs or enhancements to work on. If you have an idea for an extension to TPOT, please file a new issue so we can discuss it.</p>"},{"location":"contributing/#project-layout","title":"Project layout","text":"<p>The latest stable release of TPOT is on the master branch, whereas the latest version of TPOT in development is on the development branch. Make sure you are looking at and working on the correct branch if you're looking to contribute code.</p> <p>In terms of directory structure:</p> <ul> <li>All of TPOT's code sources are in the <code>tpot</code> directory</li> <li>The documentation sources are in the <code>docs_sources</code> directory</li> <li>Images in the documentation are in the <code>images</code> directory</li> <li>Tutorials for TPOT are in the <code>tutorials</code> directory</li> <li>Unit tests for TPOT are in the <code>tests.py</code> file</li> </ul> <p>Make sure to familiarize yourself with the project layout before making any major contributions, and especially make sure to send all code changes to the <code>development</code> branch.</p>"},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>The preferred way to contribute to TPOT is to fork the main repository on GitHub:</p> <ol> <li> <p>Fork the project repository:    click on the 'Fork' button near the top of the page. This creates    a copy of the code under your account on the GitHub server.</p> </li> <li> <p>Clone this copy to your local disk:</p> <pre><code>  $ git clone git@github.com:YourUsername/tpot.git\n  $ cd tpot\n</code></pre> </li> <li> <p>Create a branch to hold your changes:</p> <pre><code>  $ git checkout -b my-contribution\n</code></pre> </li> <li> <p>Make sure your local environment is setup correctly for development. Installation instructions are almost identical to the user instructions except that TPOT should not be installed. If you have TPOT installed on your computer then make sure you are using a virtual environment that does not have TPOT installed. Furthermore, you should make sure you have installed the <code>nose</code> package into your development environment so that you can test changes locally.</p> <pre><code>  $ conda install nose\n</code></pre> </li> <li> <p>Start making changes on your newly created branch, remembering to never work on the <code>master</code> branch! Work on this copy on your computer using Git to do the version control.</p> </li> <li> <p>Once some changes are saved locally, you can use your tweaked version of TPOT by navigating to the project's base directory and running TPOT directly from the command line:</p> <pre><code>  $ python -m tpot.driver\n</code></pre> <p>or by running script that imports and uses the TPOT module with code similar to <code>from tpot import TPOTClassifier</code></p> </li> <li> <p>To check your changes haven't broken any existing tests and to check new tests you've added pass run the following (note, you must have the <code>nose</code> package installed within your dev environment for this to work):</p> <pre><code>  $ nosetests -s -v\n</code></pre> </li> <li> <p>When you're done editing and local testing, run:</p> <pre><code>  $ git add modified_files\n  $ git commit\n</code></pre> </li> </ol> <p>to record your changes in Git, then push them to GitHub with:</p> <pre><code>      $ git push -u origin my-contribution\n</code></pre> <p>Finally, go to the web page of your fork of the TPOT repo, and click 'Pull Request' (PR) to send your changes to the maintainers for review. Make sure that you send your PR to the <code>development</code> branch, as the <code>master</code> branch is reserved for the latest stable release. This will start the CI server to check all the project's unit tests run and send an email to the maintainers.</p> <p>(If any of the above seems like magic to you, then look up the Git documentation on the web.)</p>"},{"location":"contributing/#before-submitting-your-pull-request","title":"Before submitting your pull request","text":"<p>Before you submit a pull request for your contribution, please work through this checklist to make sure that you have done everything necessary so we can efficiently review and accept your changes.</p> <p>If your contribution changes TPOT in any way:</p> <ul> <li> <p>Update the documentation so all of your changes are reflected there.</p> </li> <li> <p>Update the README if anything there has changed.</p> </li> </ul> <p>If your contribution involves any code changes:</p> <ul> <li> <p>Update the project unit tests to test your code changes.</p> </li> <li> <p>Make sure that your code is properly commented with docstrings and comments explaining your rationale behind non-obvious coding practices.</p> </li> <li> <p>If your code affected any of the pipeline operators, make sure that the corresponding export functionality reflects those changes.</p> </li> </ul> <p>If your contribution requires a new library dependency:</p> <ul> <li> <p>Double-check that the new dependency is easy to install via <code>pip</code> or Anaconda and supports both Python 2 and 3. If the dependency requires a complicated installation, then we most likely won't merge your changes because we want to keep TPOT easy to install.</p> </li> <li> <p>Add the required version of the library to .travis.yml</p> </li> <li> <p>Add a line to pip install the library to .travis_install.sh</p> </li> <li> <p>Add a line to print the version of the library to .travis_install.sh</p> </li> <li> <p>Similarly add a line to print the version of the library to .travis_test.sh</p> </li> </ul>"},{"location":"contributing/#after-submitting-your-pull-request","title":"After submitting your pull request","text":"<p>After submitting your pull request, Travis-CI will automatically run unit tests on your changes and make sure that your updated code builds and runs on Python 2 and 3. We also use services that automatically check code quality and test coverage.</p> <p>Check back shortly after submitting your pull request to make sure that your code passes these checks. If any of the checks come back with a red X, then do your best to address the errors.</p>"},{"location":"examples/","title":"Overview","text":"<p>The following sections illustrate the usage of TPOT with various datasets, each belonging to a typical class of machine learning tasks.</p> Dataset Task Task class Dataset description Jupyter notebook Iris flower classification classification link link Optical Recognition of Handwritten Digits digit recognition (image) classification link link Boston housing prices modeling regression link N/A Titanic survival analysis classification link link Bank Marketing subscription prediction classification link link MAGIC Gamma Telescope event detection classification link link cuML Classification Example random classification problem classification link link cuML Regression Example random regression problem regression link link <p>Notes: - For details on how the <code>fit()</code>, <code>score()</code> and <code>export()</code> methods work, refer to the usage documentation. - Upon re-running the experiments, your resulting pipelines may differ (to some extent) from the ones demonstrated here.</p>"},{"location":"examples/#iris-flower-classification","title":"Iris flower classification","text":"<p>The following code illustrates how TPOT can be employed for performing a simple classification task over the Iris dataset.</p> <pre><code>from tpot import TPOTClassifier\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nimport numpy as np\niris = load_iris()\nX_train, X_test, y_train, y_test = train_test_split(iris.data.astype(np.float64),\niris.target.astype(np.float64), train_size=0.75, test_size=0.25, random_state=42)\ntpot = TPOTClassifier(generations=5, population_size=50, verbosity=2, random_state=42)\ntpot.fit(X_train, y_train)\nprint(tpot.score(X_test, y_test))\ntpot.export('tpot_iris_pipeline.py')\n</code></pre> <p>Running this code should discover a pipeline (exported as <code>tpot_iris_pipeline.py</code>) that achieves about 97% test accuracy:</p> <pre><code>import numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import Normalizer\nfrom tpot.export_utils import set_param_recursive\n# NOTE: Make sure that the outcome column is labeled 'target' in the data file\ntpot_data = pd.read_csv('PATH/TO/DATA/FILE', sep='COLUMN_SEPARATOR', dtype=np.float64)\nfeatures = tpot_data.drop('target', axis=1)\ntraining_features, testing_features, training_target, testing_target = \\\n            train_test_split(features, tpot_data['target'], random_state=42)\n# Average CV score on the training set was: 0.9826086956521738\nexported_pipeline = make_pipeline(\nNormalizer(norm=\"l2\"),\nKNeighborsClassifier(n_neighbors=5, p=2, weights=\"distance\")\n)\n# Fix random state for all the steps in exported pipeline\nset_param_recursive(exported_pipeline.steps, 'random_state', 42)\nexported_pipeline.fit(training_features, training_target)\nresults = exported_pipeline.predict(testing_features)\n</code></pre>"},{"location":"examples/#digits-dataset","title":"Digits dataset","text":"<p>Below is a minimal working example with the optical recognition of handwritten digits dataset, which is an image classification problem.</p> <pre><code>from tpot import TPOTClassifier\nfrom sklearn.datasets import load_digits\nfrom sklearn.model_selection import train_test_split\ndigits = load_digits()\nX_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,\ntrain_size=0.75, test_size=0.25, random_state=42)\ntpot = TPOTClassifier(generations=5, population_size=50, verbosity=2, random_state=42)\ntpot.fit(X_train, y_train)\nprint(tpot.score(X_test, y_test))\ntpot.export('tpot_digits_pipeline.py')\n</code></pre> <p>Running this code should discover a pipeline (exported as <code>tpot_digits_pipeline.py</code>) that achieves about 98% test accuracy:</p> <pre><code>import numpy as np\nimport pandas as pd\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import make_pipeline, make_union\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom tpot.builtins import StackingEstimator\nfrom tpot.export_utils import set_param_recursive\n# NOTE: Make sure that the outcome column is labeled 'target' in the data file\ntpot_data = pd.read_csv('PATH/TO/DATA/FILE', sep='COLUMN_SEPARATOR', dtype=np.float64)\nfeatures = tpot_data.drop('target', axis=1)\ntraining_features, testing_features, training_target, testing_target = \\\n            train_test_split(features, tpot_data['target'], random_state=42)\n# Average CV score on the training set was: 0.9799428471757372\nexported_pipeline = make_pipeline(\nPolynomialFeatures(degree=2, include_bias=False, interaction_only=False),\nStackingEstimator(estimator=LogisticRegression(C=0.1, dual=False, penalty=\"l1\")),\nRandomForestClassifier(bootstrap=True, criterion=\"entropy\", max_features=0.35000000000000003, min_samples_leaf=20, min_samples_split=19, n_estimators=100)\n)\n# Fix random state for all the steps in exported pipeline\nset_param_recursive(exported_pipeline.steps, 'random_state', 42)\nexported_pipeline.fit(training_features, training_target)\nresults = exported_pipeline.predict(testing_features)\n</code></pre>"},{"location":"examples/#boston-housing-prices-modeling","title":"Boston housing prices modeling","text":"<p>The following code illustrates how TPOT can be employed for performing a regression task over the Boston housing prices dataset.</p> <pre><code>from tpot import TPOTRegressor\nfrom sklearn.datasets import load_boston\nfrom sklearn.model_selection import train_test_split\nhousing = load_boston()\nX_train, X_test, y_train, y_test = train_test_split(housing.data, housing.target,\ntrain_size=0.75, test_size=0.25, random_state=42)\ntpot = TPOTRegressor(generations=5, population_size=50, verbosity=2, random_state=42)\ntpot.fit(X_train, y_train)\nprint(tpot.score(X_test, y_test))\ntpot.export('tpot_boston_pipeline.py')\n</code></pre> <p>Running this code should discover a pipeline (exported as <code>tpot_boston_pipeline.py</code>) that achieves at least 10 mean squared error (MSE) on the test set:</p> <pre><code>import numpy as np\nimport pandas as pd\nfrom sklearn.ensemble import ExtraTreesRegressor\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom tpot.export_utils import set_param_recursive\n# NOTE: Make sure that the outcome column is labeled 'target' in the data file\ntpot_data = pd.read_csv('PATH/TO/DATA/FILE', sep='COLUMN_SEPARATOR', dtype=np.float64)\nfeatures = tpot_data.drop('target', axis=1)\ntraining_features, testing_features, training_target, testing_target = \\\n            train_test_split(features, tpot_data['target'], random_state=42)\n# Average CV score on the training set was: -10.812040755234403\nexported_pipeline = make_pipeline(\nPolynomialFeatures(degree=2, include_bias=False, interaction_only=False),\nExtraTreesRegressor(bootstrap=False, max_features=0.5, min_samples_leaf=2, min_samples_split=3, n_estimators=100)\n)\n# Fix random state for all the steps in exported pipeline\nset_param_recursive(exported_pipeline.steps, 'random_state', 42)\nexported_pipeline.fit(training_features, training_target)\nresults = exported_pipeline.predict(testing_features)\n</code></pre>"},{"location":"examples/#titanic-survival-analysis","title":"Titanic survival analysis","text":"<p>To see the TPOT applied the Titanic Kaggle dataset, see the Jupyter notebook here. This example shows how to take a messy dataset and preprocess it such that it can be used in scikit-learn and TPOT.</p>"},{"location":"examples/#portuguese-bank-marketing","title":"Portuguese Bank Marketing","text":"<p>The corresponding Jupyter notebook, containing the associated data preprocessing and analysis, can be found here.</p>"},{"location":"examples/#magic-gamma-telescope","title":"MAGIC Gamma Telescope","text":"<p>The corresponding Jupyter notebook, containing the associated data preprocessing and analysis, can be found here.</p>"},{"location":"examples/#neural-network-classifier-using-tpot-nn","title":"Neural network classifier using TPOT-NN","text":"<p>By loading the TPOT-NN configuration dictionary, PyTorch estimators will be included for classification. Users can also create their own NN configuration dictionary that includes <code>tpot.builtins.PytorchLRClassifier</code> and/or <code>tpot.builtins.PytorchMLPClassifier</code>, or they can specify them using a template string, as shown in the following example:</p> <pre><code>from tpot import TPOTClassifier\nfrom sklearn.datasets import make_blobs\nfrom sklearn.model_selection import train_test_split\nX, y = make_blobs(n_samples=100, centers=2, n_features=3, random_state=42)\nX_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.75, test_size=0.25)\nclf = TPOTClassifier(config_dict='TPOT NN', template='Selector-Transformer-PytorchLRClassifier',\nverbosity=2, population_size=10, generations=10)\nclf.fit(X_train, y_train)\nprint(clf.score(X_test, y_test))\nclf.export('tpot_nn_demo_pipeline.py')\n</code></pre> <p>This example is somewhat trivial, but it should result in nearly 100% classification accuracy.</p>"},{"location":"installing/","title":"Installation","text":"<p>TPOT is built on top of several existing Python libraries, including:</p> <ul> <li> <p>NumPy</p> </li> <li> <p>SciPy</p> </li> <li> <p>scikit-learn</p> </li> <li> <p>DEAP</p> </li> <li> <p>update_checker</p> </li> <li> <p>tqdm</p> </li> <li> <p>stopit</p> </li> <li> <p>pandas</p> </li> <li> <p>joblib</p> </li> <li> <p>xgboost</p> </li> </ul> <p>Most of the necessary Python packages can be installed via the Anaconda Python distribution, which we strongly recommend that you use. Support for Python 3.4 and below has been officially dropped since version 0.11.0.</p> <p>You can install TPOT using <code>pip</code> or <code>conda-forge</code>.</p>"},{"location":"installing/#pip","title":"pip","text":"<p>NumPy, SciPy, scikit-learn, pandas, joblib, and PyTorch can be installed in Anaconda via the command:</p> <pre><code>conda install numpy scipy scikit-learn pandas joblib pytorch\n</code></pre> <p>DEAP, update_checker, tqdm, stopit and xgboost can be installed with <code>pip</code> via the command:</p> <pre><code>pip install deap update_checker tqdm stopit xgboost\n</code></pre> <p>Windows users: pip installation may not work on some Windows environments, and it may cause unexpected errors. If you have issues installing XGBoost, check the XGBoost installation documentation.</p> <p>If you plan to use Dask for parallel training, make sure to install dask[delay] and dask[dataframe] and dask_ml. It is noted that dask-ml&gt;=1.7 requires distributed&gt;=2.4.0 and scikit-learn&gt;=0.23.0.</p> <pre><code>pip install dask[delayed] dask[dataframe] dask-ml fsspec&gt;=0.3.3 distributed&gt;=2.10.0\n</code></pre> <p>If you plan to use the TPOT-MDR configuration, make sure to install scikit-mdr and scikit-rebate:</p> <pre><code>pip install scikit-mdr skrebate\n</code></pre> <p>To enable support for PyTorch-based neural networks (TPOT-NN), you will need to install PyTorch. TPOT-NN will work with either CPU or GPU PyTorch, but we strongly recommend using a GPU version, if possible, as CPU PyTorch models tend to train very slowly.</p> <p>We recommend following PyTorch's installation instructions customized for your operating system and Python distribution.</p> <p>Finally to install TPOT itself, run the following command:</p> <pre><code>pip install tpot\n</code></pre>"},{"location":"installing/#conda-forge","title":"conda-forge","text":"<p>To install tpot and its core dependencies you can use:</p> <pre><code>conda install -c conda-forge tpot\n</code></pre> <p>To install additional dependencies you can use:</p> <pre><code>conda install -c conda-forge tpot xgboost dask dask-ml scikit-mdr skrebate\n</code></pre> <p>As mentioned above, we recommend following PyTorch's installation instructions for installing it to enable support for PyTorch-based neural networks (TPOT-NN).</p>"},{"location":"installing/#installation-for-using-tpot-cuml-configuration","title":"Installation for using TPOT-cuML configuration","text":"<p>With \"TPOT cuML\" configuration (see built-in configurations), TPOT will search over a restricted configuration using the GPU-accelerated estimators in RAPIDS cuML and DMLC XGBoost. This configuration requires an NVIDIA Pascal architecture or better GPU with compute capability 6.0+, and that the library cuML is installed. With this configuration, all model training and predicting will be GPU-accelerated. This configuration is particularly useful for medium-sized and larger datasets on which CPU-based estimators are a common bottleneck, and works for both the <code>TPOTClassifier</code> and <code>TPOTRegressor</code>.</p> <p>Please download this conda environment yml file to install TPOT for using TPOT-cuML configuration.</p> <pre><code>conda env create -f tpot-cuml.yml -n tpot-cuml\nconda activate tpot-cuml\n</code></pre>"},{"location":"installing/#installation-problems","title":"Installation problems","text":"<p>Please file a new issue if you run into installation problems.</p>"},{"location":"related/","title":"Related","text":"<p>Other Automated Machine Learning (AutoML) tools and related projects:</p> Name Language License Description Auto-WEKA Java GPL-v3 Automated model selection and hyper-parameter tuning for Weka models. auto-sklearn Python BSD-3-Clause An automated machine learning toolkit and a drop-in replacement for a scikit-learn estimator. auto_ml Python MIT Automated machine learning for analytics &amp; production. Supports manual feature type declarations. H2O AutoML Java with Python, Scala &amp; R APIs and web GUI Apache 2.0 Automated: data prep, hyperparameter tuning, random grid search and stacked ensembles in a distributed ML platform. devol Python MIT Automated deep neural network design via genetic programming. MLBox Python BSD-3-Clause Accurate hyper-parameter optimization in high-dimensional space with support for distributed computing. Recipe C GPL-v3 Machine-learning pipeline optimization through genetic programming. Uses grammars to define pipeline structure. Xcessiv Python Apache 2.0 A web-based application for quick, scalable, and automated hyper-parameter tuning and stacked ensembling in Python. GAMA Python Apache 2.0 Machine-learning pipeline optimization through asynchronous evaluation based genetic programming."},{"location":"releases/","title":"Release Notes","text":""},{"location":"releases/#version-0120","title":"Version 0.12.0","text":"<ul> <li>Fix numpy compatibility</li> <li>Dask optimizations</li> <li>Minor bug fixes</li> </ul>"},{"location":"releases/#version-0117","title":"Version 0.11.7","text":"<ul> <li>Fix compatibility issue with scikit-learn 0.24 and xgboost 1.3.0</li> <li>Fix a bug causing that TPOT does not work when classifying more than 50 classes</li> <li>Add initial support <code>Resampler</code> from <code>imblearn</code></li> <li>Fix minor bugs</li> </ul>"},{"location":"releases/#version-0116","title":"Version 0.11.6","text":"<ul> <li>Fix a bug causing point mutation function does not work properly with using <code>template</code> option</li> <li>Add a new built configuration called \"TPOT cuML\" which TPOT will search over a restricted configuration using the GPU-accelerated estimators in RAPIDS cuML and DMLC XGBoost. This configuration requires an NVIDIA Pascal architecture or better GPU with compute capability 6.0+, and that the library cuML is installed.</li> <li>Add string path support for log/log_file parameter</li> <li>Fix a bug in version 0.11.5 causing no update in stdout after each generation</li> <li>Fix minor bugs</li> </ul>"},{"location":"releases/#version-0115","title":"Version 0.11.5","text":"<ul> <li>Make <code>Pytorch</code> as an optional dependency</li> <li>Refine installation documentation</li> </ul>"},{"location":"releases/#version-0114","title":"Version 0.11.4","text":"<ul> <li>Add a new built configuration \"TPOT NN\" which includes all operators in \"Default TPOT\" plus additional neural network estimators written in PyTorch (currently <code>tpot.builtins.PytorchLRClassifier</code> and <code>tpot.builtins.PytorchMLPClassifier</code> for classification tasks only)</li> <li>Refine <code>log_file</code> parameter's behavior</li> </ul>"},{"location":"releases/#version-0113","title":"Version 0.11.3","text":"<ul> <li>Fix a bug in TPOTRegressor in v0.11.2</li> <li>Add <code>-log</code> option in command line interface to save process log to a file.</li> </ul>"},{"location":"releases/#version-0112","title":"Version 0.11.2","text":"<ul> <li>Fix <code>early_stop</code> parameter does not work properly</li> <li>TPOT built-in <code>OneHotEncoder</code> can refit to different datasets</li> <li>Fix the issue that the attribute <code>evaluated_individuals_</code> cannot record correct generation info.</li> <li>Add a new parameter <code>log_file</code> to output logs to a file instead of <code>sys.stdout</code></li> <li>Fix some code quality issues and mistakes in documentations</li> <li>Fix minor bugs</li> </ul>"},{"location":"releases/#version-0111","title":"Version 0.11.1","text":"<ul> <li>Fix compatibility issue with scikit-learn v0.22</li> <li><code>warm_start</code> now saves both Primitive Sets and evaluated_pipelines_ from previous runs;</li> <li>Fix the error that TPOT assign wrong fitness scores to non-evaluated pipelines (interrupted by <code>max_min_mins</code> or <code>KeyboardInterrupt</code>) ;</li> <li>Fix the bug that mutation operator cannot generate new pipeline when template is not default value and <code>warm_start</code> is True;</li> <li>Fix the bug that <code>max_time_mins</code> cannot stop optimization process when search space is limited.  </li> <li>Fix a bug in exported codes when the exported pipeline is only 1 estimator</li> <li>Fix spelling mistakes in documentations</li> <li>Fix some code quality issues</li> </ul>"},{"location":"releases/#version-0110","title":"Version 0.11.0","text":"<ul> <li>Support for Python 3.4 and below has been officially dropped. Also support for scikit-learn 0.20 or below has been dropped.</li> <li>The support of a metric function with the signature <code>score_func(y_true, y_pred)</code> for <code>scoring parameter</code> has been dropped.</li> <li>Refine <code>StackingEstimator</code> for not stacking NaN/Infinity predication probabilities.</li> <li>Fix a bug that population doesn't persist by <code>warm_start=True</code> when <code>max_time_mins</code> is not default value.</li> <li>Now the <code>random_state</code> parameter in TPOT is used for pipeline evaluation instead of using a fixed random seed of 42 before. The <code>set_param_recursive</code> function has been moved to <code>export_utils.py</code> and it can be used in exported codes for setting <code>random_state</code> recursively in scikit-learn Pipeline. It is used to set <code>random_state</code> in <code>fitted_pipeline_</code> attribute and exported pipelines.</li> <li>TPOT can independently use <code>generations</code> and <code>max_time_mins</code> to limit the optimization process through using one of the parameters or both.</li> <li><code>.export()</code> function will return string of exported pipeline if output filename is not specified.</li> <li>Add <code>SGDClassifier</code> and <code>SGDRegressor</code> into TPOT default configs.</li> <li>Documentation has been updated</li> <li>Fix minor bugs.</li> </ul>"},{"location":"releases/#version-0102","title":"Version 0.10.2","text":"<ul> <li>TPOT v0.10.2 is the last version to support Python 2.7 and Python 3.4.</li> <li>Minor updates for fixing compatibility issues with the latest version of scikit-learn (version &gt; 0.21) and xgboost (v0.90)</li> <li>Default value of <code>template</code> parameter is changed to <code>None</code> instead.</li> <li>Fix errors in documentation</li> </ul>"},{"location":"releases/#version-0101","title":"Version 0.10.1","text":"<ul> <li>Add <code>data_file_path</code> option into <code>expert</code> function for replacing <code>'PATH/TO/DATA/FILE'</code> to customized dataset path in exported scripts. (Related issue #838)</li> <li>Change python version in CI tests to 3.7</li> <li>Add CI tests for macOS.</li> </ul>"},{"location":"releases/#version-0100","title":"Version 0.10.0","text":"<ul> <li>Add a new <code>template</code> option to specify a desired structure for machine learning pipeline in TPOT. Check TPOT API (it will be updated once it is merge to master branch).</li> <li>Add <code>FeatureSetSelector</code> operator into TPOT for feature selection based on priori export knowledge. Please check our preprint paper for more details (Note: it was named <code>DatasetSelector</code> in 1st version paper but we will rename to FeatureSetSelector in next version of the paper)</li> <li>Refine <code>n_jobs</code> parameter to accept value below -1. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for n_jobs = -2, all CPUs but one are used.</li> <li>Now <code>memory</code>  parameter can create memory cache directory if it does not exist.</li> <li>Fix minor bugs.</li> </ul>"},{"location":"releases/#version-096","title":"Version 0.9.6","text":"<ul> <li>Fix a bug causing that <code>max_time_mins</code> parameter doesn't work when <code>use_dask=True</code> in TPOT 0.9.5</li> <li>Now TPOT saves best pareto values best pareto pipeline s in checkpoint folder</li> <li>TPOT raises <code>ImportError</code> if operators in the TPOT configuration are not available when <code>verbosity&gt;2</code></li> <li>Thank @PGijsbers for the suggestions. Now TPOT can save scores of individuals already evaluated in any generation even the evaluation process of that generation is interrupted/stopped. But it is noted that, in this case, TPOT will raise this warning message: <code>WARNING: TPOT may not provide a good pipeline if TPOT is stopped/interrupted in a early generation.</code>, because the pipelines in early generation, e.g. 1st generation, are evolved/modified very limited times via evolutionary algorithm.</li> <li>Fix bugs in configuration of <code>TPOTRegressor</code></li> <li>Error fixes in documentation</li> </ul>"},{"location":"releases/#version-095","title":"Version 0.9.5","text":"<ul> <li> <p>TPOT now supports integration with Dask for parallelization + smart caching. Big thanks to the Dask dev team for making this happen!</p> </li> <li> <p>TPOT now supports for imputation/sparse matrices into <code>predict</code> and <code>predict_proba</code> functions.</p> </li> <li> <p><code>TPOTClassifier</code> and <code>TPOTRegressor</code> now follows scikit-learn estimator API.</p> </li> <li> <p>We refined scoring parameter in TPOT API for accepting <code>Scorer</code> object.</p> </li> <li> <p>We refined parameters in VarianceThreshold and FeatureAgglomeration.</p> </li> <li> <p>TPOT now supports using memory caching within a Pipeline via an optional <code>memory</code> parameter.</p> </li> <li> <p>We improved documentation of TPOT.</p> </li> </ul>"},{"location":"releases/#version-09","title":"Version 0.9","text":"<ul> <li> <p>TPOT now supports sparse matrices with a new built-in TPOT configuration, \"TPOT sparse\". We are using a custom OneHotEncoder implementation that supports missing values and continuous features.</p> </li> <li> <p>We have added an \"early stopping\" option for stopping the optimization process if no improvement is made within a set number of generations. Look up the <code>early_stop</code> parameter to access this functionality.</p> </li> <li> <p>TPOT now reduces the number of duplicated pipelines between generations, which saves you time during the optimization process.</p> </li> <li> <p>TPOT now supports custom scoring functions via the command-line mode.</p> </li> <li> <p>We have added a new optional argument, <code>periodic_checkpoint_folder</code>, that allows TPOT to periodically save the best pipeline so far to a local folder during optimization process.</p> </li> <li> <p>TPOT no longer uses <code>sklearn.externals.joblib</code> when <code>n_jobs=1</code> to avoid the potential freezing issue that scikit-learn suffers from.</p> </li> <li> <p>We have added <code>pandas</code> as a dependency to read input datasets instead of <code>numpy.recfromcsv</code>. NumPy's <code>recfromcsv</code> function is unable to parse datasets with complex data types.</p> </li> <li> <p>Fixed a bug that <code>DEFAULT</code> in the parameter(s) of nested estimator raises <code>KeyError</code> when exporting pipelines.</p> </li> <li> <p>Fixed a bug related to setting <code>random_state</code> in nested estimators. The issue would happen with pipeline with <code>SelectFromModel</code> (<code>ExtraTreesClassifier</code> as nested estimator) or <code>StackingEstimator</code> if nested estimator has <code>random_state</code> parameter.</p> </li> <li> <p>Fixed a bug in the missing value imputation function in TPOT to impute along columns instead rows.</p> </li> <li> <p>Refined input checking for sparse matrices in TPOT.</p> </li> <li> <p>Refined the TPOT pipeline mutation operator.</p> </li> </ul>"},{"location":"releases/#version-08","title":"Version 0.8","text":"<ul> <li> <p>TPOT now detects whether there are missing values in your dataset and replaces them with the median value of the column.</p> </li> <li> <p>TPOT now allows you to set a <code>group</code> parameter in the <code>fit</code> function so you can use the GroupKFold cross-validation strategy.</p> </li> <li> <p>TPOT now allows you to set a subsample ratio of the training instance with the <code>subsample</code> parameter. For example, setting <code>subsample</code>=0.5 tells TPOT to create a fixed subsample of half of the training data for the pipeline optimization process. This parameter can be useful for speeding up the pipeline optimization process, but may give less accurate performance estimates from cross-validation.</p> </li> <li> <p>TPOT now has more built-in configurations, including TPOT MDR and TPOT light, for both classification and regression problems.</p> </li> <li> <p><code>TPOTClassifier</code> and <code>TPOTRegressor</code> now expose three useful internal attributes, <code>fitted_pipeline_</code>, <code>pareto_front_fitted_pipelines_</code>, and <code>evaluated_individuals_</code>. These attributes are described in the API documentation.</p> </li> <li> <p>Oh, TPOT now has thorough API documentation. Check it out!</p> </li> <li> <p>Fixed a reproducibility issue where setting <code>random_seed</code> didn't necessarily result in the same results every time. This bug was present since TPOT v0.7.</p> </li> <li> <p>Refined input checking in TPOT.</p> </li> <li> <p>Removed Python 2 uncompliant code.</p> </li> </ul>"},{"location":"releases/#version-07","title":"Version 0.7","text":"<ul> <li> <p>TPOT now has multiprocessing support. TPOT allows you to use multiple processes in parallel to accelerate the pipeline optimization process in TPOT with the <code>n_jobs</code> parameter.</p> </li> <li> <p>TPOT now allows you to customize the operators and parameters considered during the optimization process, which can be accomplished with the new <code>config_dict</code> parameter. The format of this customized dictionary can be found in the online documentation, along with a list of built-in configurations.</p> </li> <li> <p>TPOT now allows you to specify a time limit for evaluating a single pipeline  (default limit is 5 minutes) in optimization process with the <code>max_eval_time_mins</code> parameter, so TPOT won't spend hours evaluating overly-complex pipelines.</p> </li> <li> <p>We tweaked TPOT's underlying evolutionary optimization algorithm to work even better, including using the mu+lambda algorithm. This algorithm gives you more control of how many pipelines are generated every iteration with the <code>offspring_size</code> parameter.</p> </li> <li> <p>Refined the default operators and parameters in TPOT, so TPOT 0.7 should work even better than 0.6.</p> </li> <li> <p>TPOT now supports sample weights in the fitness function if some if your samples are more important to classify correctly than others. The sample weights option works the same as in scikit-learn, e.g., <code>tpot.fit(x_train, y_train, sample_weights=sample_weights)</code>.</p> </li> <li> <p>The default scoring metric in TPOT has been changed from balanced accuracy to accuracy, the same default metric for classification algorithms in scikit-learn. Balanced accuracy can still be used by setting <code>scoring='balanced_accuracy'</code> when creating a TPOT instance.</p> </li> </ul>"},{"location":"releases/#version-06","title":"Version 0.6","text":"<ul> <li> <p>TPOT now supports regression problems! We have created two separate <code>TPOTClassifier</code> and <code>TPOTRegressor</code> classes to support classification and regression problems, respectively. The command-line interface also supports this feature through the <code>-mode</code> parameter.</p> </li> <li> <p>TPOT now allows you to specify a time limit for the optimization process with the <code>max_time_mins</code> parameter, so you don't need to guess how long TPOT will take any more to recommend a pipeline to you.</p> </li> <li> <p>Added a new operator that performs feature selection using ExtraTrees feature importance scores.</p> </li> <li> <p>XGBoost has been added as an optional dependency to TPOT. If you have XGBoost installed, TPOT will automatically detect your installation and use the <code>XGBoostClassifier</code> and <code>XGBoostRegressor</code> in its pipelines.</p> </li> <li> <p>TPOT now offers a verbosity level of 3 (\"science mode\"), which outputs the entire Pareto front instead of only the current best score. This feature may be useful for users looking to make a trade-off between pipeline complexity and score.</p> </li> </ul>"},{"location":"releases/#version-05","title":"Version 0.5","text":"<ul> <li>Major refactor: Each operator is defined in a separate class file. Hooray for easier-to-maintain code!</li> <li>TPOT now exports directly to scikit-learn Pipelines instead of hacky code.</li> <li>Internal representation of individuals now uses scikit-learn pipelines.</li> <li>Parameters for each operator have been optimized so TPOT spends less time exploring useless parameters.</li> <li>We have removed pandas as a dependency and instead use numpy matrices to store the data.</li> <li>TPOT now uses k-fold cross-validation when evaluating pipelines, with a default k = 3. This k parameter can be tuned when creating a new TPOT instance.</li> <li>Improved scoring function support: Even though TPOT uses balanced accuracy by default, you can now have TPOT use any of the scoring functions that <code>cross_val_score</code> supports.</li> <li>Added the scikit-learn Normalizer preprocessor.</li> <li>Minor text fixes.</li> </ul>"},{"location":"releases/#version-04","title":"Version 0.4","text":"<p>In TPOT 0.4, we've made some major changes to the internals of TPOT and added some convenience functions. We've summarized the changes below.</p> <ul> <li>Added new sklearn models and preprocessors  <ul> <li>AdaBoostClassifier</li> <li>BernoulliNB</li> <li>ExtraTreesClassifier</li> <li>GaussianNB</li> <li>MultinomialNB</li> <li>LinearSVC</li> <li>PassiveAggressiveClassifier</li> <li>GradientBoostingClassifier</li> <li>RBFSampler</li> <li>FastICA</li> <li>FeatureAgglomeration</li> <li>Nystroem</li> </ul></li> <li>Added operator that inserts virtual features for the count of features with values of zero</li> <li>Reworked parameterization of TPOT operators <ul> <li>Reduced parameter search space with information from a scikit-learn benchmark</li> <li>TPOT no longer generates arbitrary parameter values, but uses a fixed parameter set instead</li> </ul></li> <li>Removed XGBoost as a dependency <ul> <li>Too many users were having install issues with XGBoost</li> <li>Replaced with scikit-learn's GradientBoostingClassifier</li> </ul></li> <li>Improved descriptiveness of TPOT command line parameter documentation</li> <li>Removed min/max/avg details during fit() when verbosity &gt; 1  <ul> <li>Replaced with tqdm progress bar</li> <li>Added tqdm as a dependency</li> </ul></li> <li>Added <code>fit_predict()</code> convenience function</li> <li>Added <code>get_params()</code> function so TPOT can operate in scikit-learn's <code>cross_val_score</code> &amp; related functions</li> </ul>"},{"location":"releases/#version-03","title":"Version 0.3","text":"<ul> <li>We revised the internal optimization process of TPOT to make it more efficient, in particular in regards to the model parameters that TPOT optimizes over.</li> </ul>"},{"location":"releases/#version-02","title":"Version 0.2","text":"<ul> <li> <p>TPOT now has the ability to export the optimized pipelines to sklearn code.</p> </li> <li> <p>Logistic regression, SVM, and k-nearest neighbors classifiers were added as pipeline operators. Previously, TPOT only included decision tree and random forest classifiers.</p> </li> <li> <p>TPOT can now use arbitrary scoring functions for the optimization process.</p> </li> <li> <p>TPOT now performs multi-objective Pareto optimization to balance model complexity (i.e., # of pipeline operators) and the score of the pipeline.</p> </li> </ul>"},{"location":"releases/#version-01","title":"Version 0.1","text":"<ul> <li> <p>First public release of TPOT.</p> </li> <li> <p>Optimizes pipelines with decision trees and random forest classifiers as the model, and uses a handful of feature preprocessors.</p> </li> </ul>"},{"location":"support/","title":"Support","text":"<p>TPOT was developed in the Computational Genetics Lab at the University of Pennsylvania with funding from the NIH under grant R01 AI117694. We are incredibly grateful for the support of the NIH and the University of Pennsylvania during the development of this project.</p> <p>The TPOT logo was designed by Todd Newmuis, who generously donated his time to the project.</p>"},{"location":"using/","title":"Using TPOT","text":""},{"location":"using/#what-to-expect-from-automl-software","title":"What to expect from AutoML software","text":"<p>Automated machine learning (AutoML) takes a higher-level approach to machine learning than most practitioners are used to, so we've gathered a handful of guidelines on what to expect when running AutoML software such as TPOT.</p> AutoML algorithms aren't intended to run for only a few minutes <p>Of course, you can run TPOT for only a few minutes and it will find a reasonably good pipeline for your dataset. However, if you don't run TPOT for long enough, it may not find the best possible pipeline for your dataset. It may even not find any suitable pipeline at all, in which case a <code>RuntimeError('A pipeline has not yet been optimized. Please call fit() first.')</code> will be raised. Often it is worthwhile to run multiple instances of TPOT in parallel for a long time (hours to days) to allow TPOT to thoroughly search the pipeline space for your dataset.</p> AutoML algorithms can take a long time to finish their search <p>AutoML algorithms aren't as simple as fitting one model on the dataset; they are considering multiple machine learning algorithms (random forests, linear models, SVMs, etc.) in a pipeline with multiple preprocessing steps (missing value imputation, scaling, PCA, feature selection, etc.), the hyperparameters for all of the models and preprocessing steps, as well as multiple ways to ensemble or stack the algorithms within the pipeline.</p> <p>As such, TPOT will take a while to run on larger datasets, but it's important to realize why. With the default TPOT settings (100 generations with 100 population size), TPOT will evaluate 10,000 pipeline configurations before finishing. To put this number into context, think about a grid search of 10,000 hyperparameter combinations for a machine learning algorithm and how long that grid search will take. That is 10,000 model configurations to evaluate with 10-fold cross-validation, which means that roughly 100,000 models are fit and evaluated on the training data in one grid search. That's a time-consuming procedure, even for simpler models like decision trees.</p> <p>Typical TPOT runs will take hours to days to finish (unless it's a small dataset), but you can always interrupt the run partway through and see the best results so far. TPOT also provides a <code>warm_start</code> parameter that lets you restart a TPOT run from where it left off.</p> AutoML algorithms can recommend different solutions for the same dataset <p>If you're working with a reasonably complex dataset or run TPOT for a short amount of time, different TPOT runs may result in different pipeline recommendations. TPOT's optimization algorithm is stochastic in nature, which means that it uses randomness (in part) to search the possible pipeline space. When two TPOT runs recommend different pipelines, this means that the TPOT runs didn't converge due to lack of time or that multiple pipelines perform more-or-less the same on your dataset.</p> <p>This is actually an advantage over fixed grid search techniques: TPOT is meant to be an assistant that gives you ideas on how to solve a particular machine learning problem by exploring pipeline configurations that you might have never considered, then leaves the fine-tuning to more constrained parameter tuning techniques such as grid search.</p>"},{"location":"using/#tpot-with-code","title":"TPOT with code","text":"<p>We've taken care to design the TPOT interface to be as similar as possible to scikit-learn.</p> <p>TPOT can be imported just like any regular Python module. To import TPOT, type:</p> <pre><code>from tpot import TPOTClassifier\n</code></pre> <p>then create an instance of TPOT as follows:</p> <pre><code>pipeline_optimizer = TPOTClassifier()\n</code></pre> <p>It's also possible to use TPOT for regression problems with the <code>TPOTRegressor</code> class. Other than the class name, a <code>TPOTRegressor</code> is used the same way as a <code>TPOTClassifier</code>. You can read more about the <code>TPOTClassifier</code> and <code>TPOTRegressor</code> classes in the API documentation.</p> <p>Some example code with custom TPOT parameters might look like:</p> <pre><code>pipeline_optimizer = TPOTClassifier(generations=5, population_size=20, cv=5,\nrandom_state=42, verbosity=2)\n</code></pre> <p>Now TPOT is ready to optimize a pipeline for you. You can tell TPOT to optimize a pipeline based on a data set with the <code>fit</code> function:</p> <pre><code>pipeline_optimizer.fit(X_train, y_train)\n</code></pre> <p>The <code>fit</code> function initializes the genetic programming algorithm to find the highest-scoring pipeline based on average k-fold cross-validation Then, the pipeline is trained on the entire set of provided samples, and the TPOT instance can be used as a fitted model.</p> <p>You can then proceed to evaluate the final pipeline on the testing set with the <code>score</code> function:</p> <pre><code>print(pipeline_optimizer.score(X_test, y_test))\n</code></pre> <p>Finally, you can tell TPOT to export the corresponding Python code for the optimized pipeline to a text file with the <code>export</code> function:</p> <pre><code>pipeline_optimizer.export('tpot_exported_pipeline.py')\n</code></pre> <p>Once this code finishes running, <code>tpot_exported_pipeline.py</code> will contain the Python code for the optimized pipeline.</p> <p>Below is a full example script using TPOT to optimize a pipeline, score it, and export the best pipeline to a file.</p> <pre><code>from tpot import TPOTClassifier\nfrom sklearn.datasets import load_digits\nfrom sklearn.model_selection import train_test_split\ndigits = load_digits()\nX_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,\ntrain_size=0.75, test_size=0.25)\npipeline_optimizer = TPOTClassifier(generations=5, population_size=20, cv=5,\nrandom_state=42, verbosity=2)\npipeline_optimizer.fit(X_train, y_train)\nprint(pipeline_optimizer.score(X_test, y_test))\npipeline_optimizer.export('tpot_exported_pipeline.py')\n</code></pre> <p>Check our examples to see TPOT applied to some specific data sets.</p>"},{"location":"using/#tpot-on-the-command-line","title":"TPOT on the command line","text":"<p>To use TPOT via the command line, enter the following command with a path to the data file:</p> <pre><code>tpot /path_to/data_file.csv\n</code></pre> <p>An example command-line call to TPOT may look like:</p> <pre><code>tpot data/mnist.csv -is , -target class -o tpot_exported_pipeline.py -g 5 -p 20 -cv 5 -s 42 -v 2\n</code></pre> <p>TPOT offers several arguments that can be provided at the command line. To see brief descriptions of these arguments, enter the following command:</p> <pre><code>tpot --help\n</code></pre> <p>Detailed descriptions of the command-line arguments are below.</p> Argument Parameter Valid values Effect -is INPUT_SEPARATOR Any string Character used to separate columns in the input file. -target TARGET_NAME Any string Name of the target column in the input file. -mode TPOT_MODE ['classification', 'regression'] Whether TPOT is being used for a supervised classification or regression problem. -o OUTPUT_FILE String path to a file File to export the code for the final optimized pipeline. -g GENERATIONS Any positive integer or None Number of iterations to run the pipeline optimization process. It must be a positive number or None. If None, the parameter max_time_mins must be defined as the runtime limit. Generally, TPOT will work better when you give it more generations (and therefore time) to optimize the pipeline.  TPOT will evaluate POPULATION_SIZE + GENERATIONS x OFFSPRING_SIZE pipelines in total. -p POPULATION_SIZE Any positive integer Number of individuals to retain in the GP population every generation. Generally, TPOT will work better when you give it more individuals (and therefore time) to optimize the pipeline.  TPOT will evaluate POPULATION_SIZE + GENERATIONS x OFFSPRING_SIZE pipelines in total. -os OFFSPRING_SIZE Any positive integer Number of offspring to produce in each GP generation.  By default, OFFSPRING_SIZE = POPULATION_SIZE. -mr MUTATION_RATE [0.0, 1.0] GP mutation rate in the range [0.0, 1.0]. This tells the GP algorithm how many pipelines to apply random changes to every generation.  We recommend using the default parameter unless you understand how the mutation rate affects GP algorithms. -xr CROSSOVER_RATE [0.0, 1.0] GP crossover rate in the range [0.0, 1.0]. This tells the GP algorithm how many pipelines to \"breed\" every generation.  We recommend using the default parameter unless you understand how the crossover rate affects GP algorithms. -scoring SCORING_FN 'accuracy', 'adjusted_rand_score', 'average_precision', 'balanced_accuracy','f1', 'f1_macro', 'f1_micro', 'f1_samples', 'f1_weighted', 'neg_log_loss', 'neg_mean_absolute_error', 'neg_mean_squared_error', 'neg_median_absolute_error', 'precision', 'precision_macro', 'precision_micro', 'precision_samples', 'precision_weighted','r2', 'recall', 'recall_macro', 'recall_micro', 'recall_samples', 'recall_weighted', 'roc_auc', 'my_module.scorer_name*' Function used to evaluate the quality of a given pipeline for the problem. By default, accuracy is used for classification and mean squared error (MSE) is used for regression.  TPOT assumes that any function with \"error\" or \"loss\" in the name is meant to be minimized, whereas any other functions will be maximized.  my_module.scorer_name: You can also specify your own function or a full python path to an existing one.  See the section on scoring functions for more details. -cv CV Any integer &gt; 1 Number of folds to evaluate each pipeline over in k-fold cross-validation during the TPOT optimization process. -sub SUBSAMPLE (0.0, 1.0] Subsample ratio of the training instance. Setting it to 0.5 means that TPOT randomly collects half of training samples for pipeline optimization process. -njobs NUM_JOBS Any positive integer or -1 Number of CPUs for evaluating pipelines in parallel during the TPOT optimization process.  Assigning this to -1 will use as many cores as available on the computer. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for n_jobs = -2, all CPUs but one are used. -maxtime MAX_TIME_MINS Any positive integer How many minutes TPOT has to optimize the pipeline.  How many minutes TPOT has to optimize the pipeline.If not None, this setting will allow TPOT to run until max_time_mins minutes elapsed and then stop. TPOT will stop earlier if generationsis set and all generations are already evaluated. -maxeval MAX_EVAL_MINS Any positive float How many minutes TPOT has to evaluate a single pipeline.  Setting this parameter to higher values will allow TPOT to consider more complex pipelines but will also allow TPOT to run longer. -s RANDOM_STATE Any positive integer Random number generator seed for reproducibility.  Set this seed if you want your TPOT run to be reproducible with the same seed and data set in the future. -config CONFIG_FILE String or file path Operators and parameter configurations in TPOT:  <ul> <li>Path for configuration file: TPOT will use the path to a configuration file for customizing the operators and parameters that TPOT uses in the optimization process</li> <li>string 'TPOT light', TPOT will use a built-in configuration with only fast models and preprocessors</li> <li>string 'TPOT MDR', TPOT will use a built-in configuration specialized for genomic studies</li> <li>string 'TPOT sparse': TPOT will use a configuration dictionary with a one-hot encoder and the operators normally included in TPOT that also support sparse matrices.</li> </ul> See the built-in configurations section for the list of configurations included with TPOT, and the custom configuration section for more information and examples of how to create your own TPOT configurations.  -template TEMPLATE String Template of predefined pipeline structure. The option is for specifying a desired structure for the machine learning pipeline evaluated in TPOT. So far this option only supports linear pipeline structure. Each step in the pipeline should be a main class of operators (Selector, Transformer, Classifier or Regressor) or a specific operator (e.g. `SelectPercentile`) defined in TPOT operator configuration. If one step is a main class, TPOT will randomly assign all subclass operators (subclasses of [`SelectorMixin`](https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/feature_selection/base.py#L17), [`TransformerMixin`](https://scikit-learn.org/stable/modules/generated/sklearn.base.TransformerMixin.html), [`ClassifierMixin`](https://scikit-learn.org/stable/modules/generated/sklearn.base.ClassifierMixin.html) or [`RegressorMixin`](https://scikit-learn.org/stable/modules/generated/sklearn.base.RegressorMixin.html) in scikit-learn) to that step. Steps in the template are delimited by \"-\", e.g. \"SelectPercentile-Transformer-Classifier\". By default value of template is None, TPOT generates tree-based pipeline randomly.  See the  template option in tpot section for more details.  -memory MEMORY String or file path If supplied, pipeline will cache each transformer after calling fit. This feature is used to avoid computing the fit transformers within a pipeline if the parameters and input data are identical with another fitted pipeline during optimization process. Memory caching mode in TPOT:  <ul> <li>Path for a caching directory: TPOT uses memory caching with the provided directory and TPOT does NOT clean the caching directory up upon shutdown.</li> <li>string 'auto': TPOT uses memory caching with a temporary directory and cleans it up upon shutdown.</li> </ul> -cf CHECKPOINT_FOLDER Folder path  If supplied, a folder you created, in which tpot will periodically save pipelines in pareto front so far while optimizing.  This is useful in multiple cases: <ul> <li>sudden death before tpot could save an optimized pipeline</li> <li>progress tracking</li> <li>grabbing a pipeline while tpot is working</li> </ul>  Example:  mkdir my_checkpoints  -cf ./my_checkpoints  -es EARLY_STOP Any positive integer  How many generations TPOT checks whether there is no improvement in optimization process.  End optimization process if there is no improvement in the set number of generations.  -v VERBOSITY {0, 1, 2, 3} How much information TPOT communicates while it is running.  0 = none, 1 = minimal, 2 = high, 3 = all.  A setting of 2 or higher will add a progress bar during the optimization procedure. -log LOG Folder path Save progress content to a file. --no-update-check Flag indicating whether the TPOT version checker should be disabled. --version Show TPOT's version number and exit. --help Show TPOT's help documentation and exit."},{"location":"using/#scoring-functions","title":"Scoring functions","text":"<p>TPOT makes use of <code>sklearn.model_selection.cross_val_score</code> for evaluating pipelines, and as such offers the same support for scoring functions. There are two ways to make use of scoring functions with TPOT:</p> <ul> <li> <p>You can pass in a string to the <code>scoring</code> parameter from the list above. Any other strings will cause TPOT to throw an exception.</p> </li> <li> <p>You can pass the callable object/function with signature <code>scorer(estimator, X, y)</code>, where <code>estimator</code> is trained estimator to use for scoring, <code>X</code> are features that will be passed to <code>estimator.predict</code> and <code>y</code> are target values for <code>X</code>. To do this, you should implement your own function. See the example below for further explanation.</p> </li> </ul> <pre><code>from tpot import TPOTClassifier\nfrom sklearn.datasets import load_digits\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import make_scorer\ndigits = load_digits()\nX_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,\ntrain_size=0.75, test_size=0.25)\n# Make a custom metric function\ndef my_custom_accuracy(y_true, y_pred):\nreturn float(sum(y_pred == y_true)) / len(y_true)\n# Make a custom a scorer from the custom metric function\n# Note: greater_is_better=False in make_scorer below would mean that the scoring function should be minimized.\nmy_custom_scorer = make_scorer(my_custom_accuracy, greater_is_better=True)\ntpot = TPOTClassifier(generations=5, population_size=20, verbosity=2,\nscoring=my_custom_scorer)\ntpot.fit(X_train, y_train)\nprint(tpot.score(X_test, y_test))\ntpot.export('tpot_digits_pipeline.py')\n</code></pre> <ul> <li>my_module.scorer_name: You can also use a custom <code>score_func(y_true, y_pred)</code> or <code>scorer(estimator, X, y)</code> function through the command line by adding the argument <code>-scoring my_module.scorer</code> to your command-line call. TPOT will import your module and use the custom scoring function from there. TPOT will include your current working directory when importing the module, so you can place it in the same directory where you are going to run TPOT. Example: <code>-scoring sklearn.metrics.auc</code> will use the function auc from sklearn.metrics module.</li> </ul>"},{"location":"using/#built-in-tpot-configurations","title":"Built-in TPOT configurations","text":"<p>TPOT comes with a handful of default operators and parameter configurations that we believe work well for optimizing machine learning pipelines. Below is a list of the current built-in configurations that come with TPOT.</p> Configuration Name Description Operators Default TPOT TPOT will search over a broad range of preprocessors, feature constructors, feature selectors, models, and parameters to find a series of operators that minimize the error of the model predictions. Some of these operators are complex and may take a long time to run, especially on larger datasets.  Note: This is the default configuration for TPOT. To use this configuration, use the default value (None) for the config_dict parameter. Classification Regression TPOT light TPOT will search over a restricted range of preprocessors, feature constructors, feature selectors, models, and parameters to find a series of operators that minimize the error of the model predictions. Only simpler and fast-running operators will be used in these pipelines, so TPOT light is useful for finding quick and simple pipelines for a classification or regression problem.  This configuration works for both the TPOTClassifier and TPOTRegressor. Classification Regression TPOT MDR TPOT will search over a series of feature selectors and Multifactor Dimensionality Reduction models to find a series of operators that maximize prediction accuracy. The TPOT MDR configuration is specialized for genome-wide association studies (GWAS), and is described in detail online here.  Note that TPOT MDR may be slow to run because the feature selection routines are computationally expensive, especially on large datasets. Classification Regression TPOT sparse TPOT uses a configuration dictionary with a one-hot encoder and the operators normally included in TPOT that also support sparse matrices.  This configuration works for both the TPOTClassifier and TPOTRegressor. Classification Regression TPOT NN TPOT uses the same configuration as \"Default TPOT\" plus additional neural network estimators written in PyTorch (currently only `tpot.builtins.PytorchLRClassifier` and `tpot.builtins.PytorchMLPClassifier`).  Currently only classification is supported, but future releases will include regression estimators. Classification TPOT cuML TPOT will search over a restricted configuration using the GPU-accelerated estimators in RAPIDS cuML and DMLC XGBoost. This configuration requires an NVIDIA Pascal architecture or better GPU with compute capability 6.0+, and that the library cuML is installed. With this configuration, all model training and predicting will be GPU-accelerated.  This configuration is particularly useful for medium-sized and larger datasets on which CPU-based estimators are a common bottleneck, and works for both the TPOTClassifier and TPOTRegressor. Classification Regression <p>To use any of these configurations, simply pass the string name of the configuration to the <code>config_dict</code> parameter (or <code>-config</code> on the command line). For example, to use the \"TPOT light\" configuration:</p> <pre><code>from tpot import TPOTClassifier\nfrom sklearn.datasets import load_digits\nfrom sklearn.model_selection import train_test_split\ndigits = load_digits()\nX_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,\ntrain_size=0.75, test_size=0.25)\ntpot = TPOTClassifier(generations=5, population_size=20, verbosity=2,\nconfig_dict='TPOT light')\ntpot.fit(X_train, y_train)\nprint(tpot.score(X_test, y_test))\ntpot.export('tpot_digits_pipeline.py')\n</code></pre>"},{"location":"using/#customizing-tpots-operators-and-parameters","title":"Customizing TPOT's operators and parameters","text":"<p>Beyond the default configurations that come with TPOT, in some cases it is useful to limit the algorithms and parameters that TPOT considers. For that reason, we allow users to provide TPOT with a custom configuration for its operators and parameters.</p> <p>The custom TPOT configuration must be in nested dictionary format, where the first level key is the path and name of the operator (e.g., <code>sklearn.naive_bayes.MultinomialNB</code>) and the second level key is the corresponding parameter name for that operator (e.g., <code>fit_prior</code>). The second level key should point to a list of parameter values for that parameter, e.g., <code>'fit_prior': [True, False]</code>.</p> <p>For a simple example, the configuration could be:</p> <pre><code>tpot_config = {\n'sklearn.naive_bayes.GaussianNB': {\n},\n'sklearn.naive_bayes.BernoulliNB': {\n'alpha': [1e-3, 1e-2, 1e-1, 1., 10., 100.],\n'fit_prior': [True, False]\n},\n'sklearn.naive_bayes.MultinomialNB': {\n'alpha': [1e-3, 1e-2, 1e-1, 1., 10., 100.],\n'fit_prior': [True, False]\n}\n}\n</code></pre> <p>in which case TPOT would only consider pipelines containing <code>GaussianNB</code>, <code>BernoulliNB</code>, <code>MultinomialNB</code>, and tune those algorithm's parameters in the ranges provided. This dictionary can be passed directly within the code to the <code>TPOTClassifier</code>/<code>TPOTRegressor</code> <code>config_dict</code> parameter, described above. For example:</p> <pre><code>from tpot import TPOTClassifier\nfrom sklearn.datasets import load_digits\nfrom sklearn.model_selection import train_test_split\ndigits = load_digits()\nX_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,\ntrain_size=0.75, test_size=0.25)\ntpot_config = {\n'sklearn.naive_bayes.GaussianNB': {\n},\n'sklearn.naive_bayes.BernoulliNB': {\n'alpha': [1e-3, 1e-2, 1e-1, 1., 10., 100.],\n'fit_prior': [True, False]\n},\n'sklearn.naive_bayes.MultinomialNB': {\n'alpha': [1e-3, 1e-2, 1e-1, 1., 10., 100.],\n'fit_prior': [True, False]\n}\n}\ntpot = TPOTClassifier(generations=5, population_size=20, verbosity=2,\nconfig_dict=tpot_config)\ntpot.fit(X_train, y_train)\nprint(tpot.score(X_test, y_test))\ntpot.export('tpot_digits_pipeline.py')\n</code></pre> <p>Command-line users must create a separate <code>.py</code> file with the custom configuration and provide the path to the file to the <code>tpot</code> call. For example, if the simple example configuration above is saved in <code>tpot_classifier_config.py</code>, that configuration could be used on the command line with the command:</p> <pre><code>tpot data/mnist.csv -is , -target class -config tpot_classifier_config.py -g 5 -p 20 -v 2 -o tpot_exported_pipeline.py\n</code></pre> <p>When using the command-line interface, the configuration file specified in the <code>-config</code> parameter must name its custom TPOT configuration <code>tpot_config</code>. Otherwise, TPOT will not be able to locate the configuration dictionary.</p> <p>For more detailed examples of how to customize TPOT's operator configuration, see the default configurations for classification and regression in TPOT's source code.</p> <p>Note that you must have all of the corresponding packages for the operators installed on your computer, otherwise TPOT will not be able to use them. For example, if XGBoost is not installed on your computer, then TPOT will simply not import nor use XGBoost in the pipelines it considers.</p>"},{"location":"using/#template-option-in-tpot","title":"Template option in TPOT","text":"<p>Template option provides a way to specify a desired structure for machine learning pipeline, which may reduce TPOT computation time and potentially provide more interpretable results. Current implementation only supports linear pipelines.</p> <p>Below is a simple example to use <code>template</code> option. The pipelines generated/evaluated in TPOT will follow this structure: 1st step is a feature selector (a subclass of <code>SelectorMixin</code>), 2nd step is a feature transformer (a subclass of <code>TransformerMixin</code>) and 3rd step is a classifier for classification (a subclass of <code>ClassifierMixin</code>). The last step must be <code>Classifier</code> for <code>TPOTClassifier</code>'s template but <code>Regressor</code> for <code>TPOTRegressor</code>. Note: although <code>SelectorMixin</code> is subclass of <code>TransformerMixin</code> in scikit-learn, but <code>Transformer</code> in this option excludes those subclasses of <code>SelectorMixin</code>.</p> <pre><code>tpot_obj = TPOTClassifier(\ntemplate='Selector-Transformer-Classifier'\n)\n</code></pre> <p>If a specific operator, e.g. <code>SelectPercentile</code>, is preferred for usage in the 1st step of the pipeline, the template can be defined like 'SelectPercentile-Transformer-Classifier'.</p>"},{"location":"using/#featuresetselector-in-tpot","title":"FeatureSetSelector in TPOT","text":"<p><code>FeatureSetSelector</code> is a special new operator in TPOT. This operator enables feature selection based on priori expert knowledge. For example, in RNA-seq gene expression analysis, this operator can be used to select one or more gene (feature) set(s) based on GO (Gene Ontology) terms or annotated gene sets Molecular Signatures Database (MSigDB) in the 1st step of pipeline via <code>template</code> option above, in order to reduce dimensions and TPOT computation time. This operator requires a dataset list in csv format. In this csv file, there are only three columns: 1st column is feature set names, 2nd column is the total number of features in one set and 3rd column is a list of feature names (if input X is pandas.DataFrame) or indexes (if input X is numpy.ndarray) delimited by \";\". Below is an example how to use this operator in TPOT.</p> <p>Please check our preprint paper for more details.</p> <pre><code>from tpot import TPOTClassifier\nimport numpy as np\nimport pandas as pd\nfrom tpot.config import classifier_config_dict\ntest_data = pd.read_csv(\"https://raw.githubusercontent.com/EpistasisLab/tpot/master/tests/tests.csv\")\ntest_X = test_data.drop(\"class\", axis=1)\ntest_y = test_data['class']\n# add FeatureSetSelector into tpot configuration\nclassifier_config_dict['tpot.builtins.FeatureSetSelector'] = {\n'subset_list': ['https://raw.githubusercontent.com/EpistasisLab/tpot/master/tests/subset_test.csv'],\n'sel_subset': [0,1] # select only one feature set, a list of index of subset in the list above\n#'sel_subset': list(combinations(range(3), 2)) # select two feature sets\n}\ntpot = TPOTClassifier(generations=5,\npopulation_size=50, verbosity=2,\ntemplate='FeatureSetSelector-Transformer-Classifier',\nconfig_dict=classifier_config_dict)\ntpot.fit(test_X, test_y)\n</code></pre>"},{"location":"using/#pipeline-caching-in-tpot","title":"Pipeline caching in TPOT","text":"<p>With the <code>memory</code> parameter, pipelines can cache the results of each transformer after fitting them. This feature is used to avoid repeated computation by transformers within a pipeline if the parameters and input data are identical to another fitted pipeline during optimization process. TPOT allows users to specify a custom directory path or <code>joblib.Memory</code> in case they want to re-use the memory cache in future TPOT runs (or a <code>warm_start</code> run).</p> <p>There are three methods for enabling memory caching in TPOT:</p> <pre><code>from tpot import TPOTClassifier\nfrom tempfile import mkdtemp\nfrom joblib import Memory\nfrom shutil import rmtree\n# Method 1, auto mode: TPOT uses memory caching with a temporary directory and cleans it up upon shutdown\ntpot = TPOTClassifier(memory='auto')\n# Method 2, with a custom directory for memory caching\ntpot = TPOTClassifier(memory='/to/your/path')\n# Method 3, with a Memory object\ncachedir = mkdtemp() # Create a temporary folder\nmemory = Memory(cachedir=cachedir, verbose=0)\ntpot = TPOTClassifier(memory=memory)\n# Clear the cache directory when you don't need it anymore\nrmtree(cachedir)\n</code></pre> <p>Note: TPOT does NOT clean up memory caches if users set a custom directory path or Memory object. We recommend that you clean up the memory caches when you don't need it anymore.</p>"},{"location":"using/#crashfreeze-issue-with-n_jobs-1-under-osx-or-linux","title":"Crash/freeze issue with n_jobs &gt; 1 under OSX or Linux","text":"<p>Internally, TPOT uses joblib to fit estimators in parallel. This is the same parallelization framework used by scikit-learn. But it may crash/freeze with n_jobs &gt; 1 under OSX or Linux as scikit-learn does, especially with large datasets.</p> <p>One solution is to configure Python's <code>multiprocessing</code> module to use the <code>forkserver</code> start method (instead of the default <code>fork</code>) to manage the process pools. You can enable the <code>forkserver</code> mode globally for your program by putting the following codes into your main script:</p> <pre><code>import multiprocessing\n# other imports, custom code, load data, define model...\nif __name__ == '__main__':\nmultiprocessing.set_start_method('forkserver')\n# call scikit-learn utils or tpot utils with n_jobs &gt; 1 here\n</code></pre> <p>More information about these start methods can be found in the multiprocessing documentation.</p>"},{"location":"using/#parallel-training-with-dask","title":"Parallel Training with Dask","text":"<p>For large problems or working on Jupyter notebook, we highly recommend that you can distribute the work on a Dask cluster. The dask-examples binder has a runnable example with a small dask cluster.</p> <p>To use your Dask cluster to fit a TPOT model, specify the <code>use_dask</code> keyword when you create the TPOT estimator. Note: if <code>use_dask=True</code>, TPOT will use as many cores as available on the your Dask cluster. If <code>n_jobs</code> is specified, then it will control the chunk size (10*<code>n_jobs</code> if it is less then offspring size) of parallel training.</p> <pre><code>estimator = TPOTEstimator(use_dask=True, n_jobs=-1)\n</code></pre> <p>This will use all the workers on your cluster to do the training, and use Dask-ML's pipeline rewriting to avoid re-fitting estimators multiple times on the same set of data. It will also provide fine-grained diagnostics in the distributed scheduler UI.</p> <p>Alternatively, Dask implements a joblib backend. You can instruct TPOT to use the distributed backend during training by specifying a <code>joblib.parallel_backend</code>:</p> <pre><code>import joblib\nimport distributed.joblib\nfrom dask.distributed import Client\n# connect to the cluster\nclient = Client('schedueler-address')\n# create the estimator normally\nestimator = TPOTClassifier(n_jobs=-1)\n# perform the fit in this context manager\nwith joblib.parallel_backend(\"dask\"):\nestimator.fit(X, y)\n</code></pre> <p>See dask's distributed joblib integration for more.</p>"},{"location":"using/#neural-networks-in-tpot-tpotnn","title":"Neural Networks in TPOT (<code>tpot.nn</code>)","text":"<p>Support for neural network models and deep learning is an experimental feature newly added to TPOT. Available neural network architectures are provided by the <code>tpot.nn</code> module. Unlike regular <code>sklearn</code> estimators, these models need to be written by hand, and must also inherit the appropriate base classes provided by <code>sklearn</code> for all of their built-in modules. In other words, they need implement methods like <code>.fit()</code>, <code>fit_transform()</code>, <code>get_params()</code>, etc., as described in detail on Developing scikit-learn estimators.</p>"},{"location":"using/#telling-tpot-to-use-built-in-pytorch-neural-network-models","title":"Telling TPOT to use built-in PyTorch neural network models","text":"<p>Mainly due to the issues described below, TPOT won't use its neural network models unless you explicitly tell it to do so. This is done as follows:</p> <ul> <li> <p>Use <code>import tpot.nn</code> before instantiating any TPOT estimators.</p> </li> <li> <p>Use a configuration dictionary that includes one or more <code>tpot.nn</code> estimators, either by writing one manually, including one from a file, or by importing the configuration in <code>tpot/config/classifier_nn.py</code>. A very simple example that will force TPOT to only use a PyTorch-based logistic regression classifier as its main estimator is as follows:</p> </li> </ul> <pre><code>tpot_config = {\n'tpot.nn.PytorchLRClassifier': {\n'learning_rate': [1e-3, 1e-2, 1e-1, 0.5, 1.]\n}\n}\n</code></pre> <ul> <li>Alternatively, use a template string including <code>PytorchLRClassifier</code> or <code>PytorchMLPClassifier</code> while loading the TPOT-NN configuration dictionary.</li> </ul> <p>Neural network models are notorious for being extremely sensitive to their initialization parameters, so you may need to heavily adjust <code>tpot.nn</code> configuration dictionaries in order to attain good performance on your dataset.</p> <p>A simple example of using TPOT-NN is shown in examples.</p>"},{"location":"using/#important-caveats","title":"Important caveats","text":"<ul> <li> <p>Neural network models (especially when they reach moderately large sizes) take a notoriously large amount of time and computing power to train. You should expect <code>tpot.nn</code> neural networks to train several orders of magnitude slower than their <code>sklearn</code> alternatives. This can be alleviated somewhat by training the models on computers with CUDA-enabled GPUs.</p> </li> <li> <p>TPOT will occasionally learn pipelines that stack several <code>sklearn</code> estimators. Mathematically, these can be nearly identical to some deep learning models. For example, by stacking several <code>sklearn.linear_model.LogisticRegression</code>s, you end up with a very close approximation of a Multilayer Perceptron; one of the simplest and most well known deep learning architectures. TPOT's genetic programming algorithms generally optimize these 'networks' much faster than PyTorch, which typically uses a more brute-force convex optimization approach.</p> </li> <li> <p>The problem of 'black box' model introspection is one of the most substantial criticisms and challenges of deep learning. This problem persists in <code>tpot.nn</code>, whereas TPOT's default estimators often are far easier to introspect.</p> </li> </ul>"}]}